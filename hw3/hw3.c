/*
 * Name, hw3.c, CS 24000, Fall 2018
 * Last updated September 13, 2018
 */
#include <stdio.h>
#include "hw3.h"
#include <math.h>

/*
 * compute the summation of 2 complex structures
 */

complex complex_add(complex a, complex b) {
  complex new_complex  = {0};
  new_complex.x = a.x + b.x;
  new_complex.y = a.y + b.y;
  return new_complex;
}

/*
 * compute the result of negative value of parmeter
 */

complex complex_neg(complex a) {
  complex new_complex = {0};
  new_complex.x = a.x * -1.0;
  new_complex.y = a.y * -1.0;
  return new_complex;
}

/*
 * compute the result get by substracting the 1st somplex by the 2nd
 */

complex complex_sub(complex a, complex b) {
  complex new_complex;
  new_complex = complex_add(a, complex_neg(b));
  return new_complex;
}

/*
 * compute the dot product of 2 complexs passed to the function
 */

double complex_dot(complex a, complex b) {
  double sum = 0.0;
  sum = (a.x * b.x) + (a.y * b.y);
  return sum;
}

/*
 * Compute the inverse complex of the complex passed to the function
 */

complex complex_inv(complex a) {
  double mag = 0.0;
  mag = (a.x * a.x + a.y * a.y);
  complex new_complex;
  new_complex.x = a.x / mag;
  new_complex.y = -1 * a.y / mag;
  return new_complex;
}

/*
 * compute the complex get by multiplying the 2 complexs
 */

complex complex_mul(complex a, complex b) {
  complex new_complex = {0};
  new_complex.x = (a.x * b.x - a.y * b.y);
  new_complex.y = (a.y * b.x + a.x * b.y);
  return new_complex;
}

/*
 * Compute the complex get by divide the 1st complex by the 2nd
 */

complex complex_div(complex a, complex b) {
  complex new_complex = {0};
  new_complex = complex_mul(a, complex_inv(b));
  return new_complex;
}

/*
 * Compute the exponential of the complex
 */

complex complex_exp(complex a) {
  complex new_complex = {0};
  new_complex.x = exp(a.x) * cos(a.y);
  new_complex.y = exp(a.x) * sin(a.y);
  return new_complex;
}

/*
 * generate Mandelbrot sequence generated by the complex number passed and
 * return number of loops
 */

int mandelbrot (complex a) {
  complex new_complex = {0};
  for (int i = 1; i < MAX_MANDELBROT; i++) {
    new_complex = complex_add(complex_mul(new_complex, new_complex), a);
    if (complex_dot(new_complex, new_complex) > 4.0) {
      return i;
    }
  }
  return MAX_MANDELBROT;
}
